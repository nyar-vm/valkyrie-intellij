class A(int, int)

class B{
    0: int,
    1: int
}

class Point<T>{
    x: T = Default::default(),
    y: T = Default::default(),
    z: T = Default::default(),
}

class Complex<T> {
ref x: &int = 0,
ref y: &int = 0,
}

class A3<T: Debug>(T, T)

forall T {T: Debug}
class A4<T>(T, T)

#[Serialize, Deserialize]
#Serialize
#Deserialize
#derive
class B {
a: int,
b: int,
}

define type A {

}


forall T, U {T: Debug}
define public static class A<T> (T, usize): Debug;
class A: Clone + Debug {
item: String = "item"
}

type alias null = Null;
forall <T>
class: T;
class A {

}
interface
bitset
tagged
forall T {}
extend Vec<T>: Iterable {
forall 'a { Self: 'a }
type Iter = <&'a [T] as IntoIterator>::IntoIter;
fn iter(&self) -> Self::Iter<'_> {
self.iter()
}
}

def method(mut arg: int)
{
arg = arg + 44;
}

let a = {

}

class A {
i: &int
}