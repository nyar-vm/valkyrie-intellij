{
    parserClass = "com.github.valkyrie.language.parser.ValkyrieParser"
    parserUtilClass = "com.github.valkyrie.language.psi.ValkyrieParserExtension"

    extends = "com.github.valkyrie.language.psi.ValkyrieElement"

    psiClassPrefix = "Valkyrie"
    psiImplClassSuffix = "Node"
    psiPackage = "com.github.valkyrie.language.psi"
    psiImplPackage = "com.github.valkyrie.language.psi_node"

    elementTypeHolderClass = "com.github.valkyrie.language.psi.ValkyrieTypes"
    elementTypeClass = "com.github.valkyrie.language.psi.ValkyrieElementType"
    tokenTypeClass = "com.github.valkyrie.language.psi.ValkyrieTokenType"

    psiImplUtilClass = "com.github.valkyrie.language.psi_node.ValkyriePsiExtension"

    tokens = [
        // comment
        COMMENT_DOCUMENT = "Comment Document"
        COMMENT = "Comment"
        COMMENT_BLOCK = "Comment Block"

        // literal
        URL = "Url"
        SYMBOL_XID = "Symbol"
        SYMBOL_RAW = "Symbol"
        BYTE = "Byte"
        STRING_START = "'"
        STRING_END = "'"
        STRING_CHAR = "String Character"
        STRING_EMPTY = "String Empty"
        COMMENT_LINE = "Comment Line"

        PARENTHESIS_L = '('
        PARENTHESIS_R = ')'
        BRACKET_L = '['
        BRACKET_R = ']'
        BRACE_L = '{'
        BRACE_R = '}'
        ANGLE_L = '<'
        ANGLE_R = '>'
        LESS = "<<"
        GREATER = ">>"
        ACCENT = '^'
        BIND = '='
        EQ = '=='
        NE = '!='
        COLON = ':'
        PROPORTION = "::"
        SEMICOLON = ';'
        DOT = '.'
        DOT2 = '..'
        DOT3 = '...'
        DOT_LESS = '..<'
        DOT_EQ = '..='
        COMMA = ','
        STAR = '*'
        AT = '@'
        DOLLAR = '$'
        HASH = '#'
        TO = "->"
        HYPHEN = "-"
        PLUS = "+"
        VERTICAL = "|"
        BANG = "!"
        AMP  = "&"
        TILDE = "~"
        QUESTION = "?"
        SLASH = "/"
        BACKSLASH = "\\"
        PERCENT = "%"
        PIPE = "|"
        IMPORT = "import"
        EXPORT = "export"
        MODULE = "module"
        IF = "if"
        ELSE = "else"
        FOR = "for"
        FORALL = "forall"
        WHILE = "while"
        MATCH = 'match'
        CATCH = 'catch'
        LET = "let"
        DEF = "def"
        CLASS = 'class'
        TRAIT = 'trait'
        TAGGED = 'tagged'
        BITFLAG = 'bitset'
        EXTENDS = 'extends'
    ]
}

valkyrie ::= ((normal_statements|top_statements) [SEMICOLON])*
private top_statements ::=
    module_statement
  | import_statement
  | export_statement
  | class_statement
  | trait_statement
  | tagged_statement
  | bitflag_statement
  | extends_statement
  | SEMICOLON
  ;
private normal_statements ::=
    if_statement
  | for_statement
  | while_statement
  | match_statement
  | let_statement
  | def_statement
  | type_statement
  ;
// ---------------------------------------------------------------------------------------------------------------------
module_statement ::= MODULE IDENTIFIER;
// ---------------------------------------------------------------------------------------------------------------------
export_statement ::= EXPORT [<<sequence namespace COMMA>>] export_block;
export_block     ::= <<brace_block import_block COMMA>>;
export_rename    ::= export_name (export_dot export_name)* [AS export_name];
export_name      ::= [AT|HASH] symbol;
export_dot       ::= PROPORTION | DOT;
AS               ::= "as"
// ---------------------------------------------------------------------------------------------------------------------
import_statement ::= IMPORT import_block;
import_block     ::= (export_name export_dot)* export_block | export_rename;
// ---------------------------------------------------------------------------------------------------------------------
if_statement     ::= (IF condition block) [ef_statement* [else_statement]]
ef_statement     ::= ELSE IF condition block;
else_statement   ::= ELSE block;
block            ::= <<brace_block expression SEMICOLON>>;
condition        ::= case_pattern BIND expression | expression;
case_pattern     ::= CASE [symbol* [namespace]] pattern;
// ---------------------------------------------------------------------------------------------------------------------
for_statement    ::= FOR (case_pattern|normal_pattern) IN expression [if_guard] block [else_statement];
if_guard         ::= IF condition;
normal_pattern   ::= symbol* pattern | <<sequence pattern_item COMMA>>;
// ---------------------------------------------------------------------------------------------------------------------
private pattern  ::=
    <<parenthesis   pattern_pair COMMA>>
  | <<bracket_block pattern_pair COMMA>>
  | <<brace_block   pattern_pair COMMA>>
  ;
pattern_pair     ::= symbol* COLON pattern_value | symbol* (DOT3|DOT2) symbol | symbol+;
pattern_item     ::= symbol* (DOT3|DOT2) symbol | symbol+;
pattern_value    ::= symbol | pattern;
// ---------------------------------------------------------------------------------------------------------------------
while_statement  ::= WHILE condition block;
// ---------------------------------------------------------------------------------------------------------------------
match_statement  ::= MATCH expression match_block;
match_block      ::= <<brace_block match_expression SEMICOLON>>;
match_expression ::= case_pattern COLON (normal_statements [SEMICOLON])+
// ---------------------------------------------------------------------------------------------------------------------
let_statement    ::=
    LET normal_pattern [let_type_hint] [BIND expression]
  | LET case_pattern BIND expression;
let_type_hint    ::= COLON <<sequence type_expr COMMA>>;
// ---------------------------------------------------------------------------------------------------------------------
def_statement       ::= DEF expression block;
// ---------------------------------------------------------------------------------------------------------------------
type_statement      ::= TYPE symbol BIND block;
// ---------------------------------------------------------------------------------------------------------------------
class_statement     ::= CLASS symbol [auto_derive] block;
auto_derive         ::= COLON <<sequence ([BANG] namespace) PLUS>>;
class_tuple         ::= <<parenthesis class_tuple_item COMMA>>;
class_brace         ::= <<brace_block class_brace_item COMMA>>;
class_tuple_item    ::= type_expr [BIND expression];
class_brace_item    ::= symbol COLON type_expr [BIND expression];
// ---------------------------------------------------------------------------------------------------------------------
trait_statement     ::= TRAIT symbol block;
// ---------------------------------------------------------------------------------------------------------------------
tagged_statement    ::= TAGGED modifiers [[PROPORTION] type_angle] tagged_block;
tagged_block        ::= <<brace_block tagged_item (COMMA|COLON)>>;
tagged_item         ::= symbol [class_tuple|class_brace];
// ---------------------------------------------------------------------------------------------------------------------
bitflag_statement   ::= BITFLAG modifiers [bitflag_layout] [auto_derive] bitflag_block;
bitflag_block       ::= <<brace_block (bitflag_item|macro_call) SEMICOLON>>;
bitflag_layout      ::= PARENTHESIS_L type_expr PARENTHESIS_R;
bitflag_item        ::= symbol BIND expression;
// ---------------------------------------------------------------------------------------------------------------------
extends_statement   ::= EXTENDS namespace block;
// ---------------------------------------------------------------------------------------------------------------------
private expression  ::= expr (op_binary expr)*;
private expr        ::= op_prefix* term (op_suffix|call_suffix|PROPORTION type_angle|slice_suffix)*;
private term        ::= list | tuple | atoms;
private op_binary   ::= type_binary | ANGLE_L | ANGLE_R | LESS | GREATER | DOT_LESS | DOT_EQ | DOT2 | DOT;
private op_prefix   ::= PLUS | MINUS | NOT | BANG | AMP | DOT3 | DOT2;
private op_suffix   ::= BANG | QUESTION;
call_suffix         ::= <<parenthesis expression COMMA>>;
// ---------------------------------------------------------------------------------------------------------------------
private type_expr   ::= expr (type_binary expr)*;
private type_binary ::= VERTICAL | EQ | NE | PLUS | MINUS;
type_angle          ::= <<angle_block type_expr COMMA>>;
// ---------------------------------------------------------------------------------------------------------------------
slice_suffix        ::= <<bracket_block slice_expression COMMA>>;
slice_expression    ::=
    [expression] COLON [expression] COLON [expression]
  | [expression] COLON [expression]
  | [expression] PROPORTION [expression]
  | expression;
// ---------------------------------------------------------------------------------------------------------------------
namehead  ::= PROPORTION namespace
namespace ::= symbol (PROPORTION symbol)*;
modifiers ::= symbol+;
macro     ::= AT namespace;
// ---------------------------------------------------------------------------------------------------------------------
macro_call    ::= macro [
    <<parenthesis expression COMMA>>
  | <<brace_block pair COMMA>>
  | <<brace_block expression SEMICOLON>>
];
// ---------------------------------------------------------------------------------------------------------------------
pair           ::= atoms COLON expression;
list           ::= <<bracket_block expression COMMA>>
tuple          ::= <<parenthesis expression COMMA>>
private atoms  ::= number | string | boolean | namespace;
boolean        ::= "true" | "false";
number         ::= number_literal [symbol];
string         ::= [symbol] string_literal
symbol         ::= SYMBOL_XID | SYMBOL_RAW;
number_literal ::= BYTE | INTEGER | DECIMAL;
string_literal ::= STRING_EMPTY | STRING_START STRING_CHAR+ STRING_END;
// ---------------------------------------------------------------------------------------------------------------------
private meta sequence ::= <<item>> (<<sp>> <<item>>)* [<<sp>>];
// parenthesis ( )
private meta parenthesis ::= PARENTHESIS_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] PARENTHESIS_R;
// bracket [ ]
private meta bracket_block ::= BRACKET_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] BRACKET_R;
// brace { }
private meta brace_block ::= BRACE_L (<<item>>|<<sp>>)* BRACE_R;
// angle < >
private meta angle_block ::= ANGLE_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] ANGLE_R;