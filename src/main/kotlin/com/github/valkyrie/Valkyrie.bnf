{
    parserClass = "com.github.valkyrie.language.parser.ValkyrieParser"
    parserUtilClass = "com.github.valkyrie.language.psi.ValkyrieParserExtension"

    extends = "com.github.valkyrie.language.psi.ValkyrieElement"

    psiClassPrefix = "Valkyrie"
    psiImplClassSuffix = "Node"
    psiPackage = "com.github.valkyrie.language.psi"
    psiImplPackage = "com.github.valkyrie.language.psi_node"

    elementTypeHolderClass = "com.github.valkyrie.language.psi.ValkyrieTypes"
    elementTypeClass = "com.github.valkyrie.language.psi.ValkyrieElementType"
    tokenTypeClass = "com.github.valkyrie.language.psi.ValkyrieTokenType"

    psiImplUtilClass = "com.github.valkyrie.language.psi_node.ValkyriePsiExtension"

    tokens = [
        // comment
        COMMENT_DOCUMENT = "Comment Document"
        COMMENT = "Comment"
        COMMENT_BLOCK = "Comment Block"

        // literal
        URL = "Url"
        SYMBOL = "Symbol"
        BYTE = "Byte"
        STRING_QUOTE = "String Quote"
        STRING_CHAR = "String Character"
        STRING_ESCAPE = "String Escaped"
        STRING_LITERAL = "String Literal"
        COMMENT_LINE = "Comment Line"

        PARENTHESIS_L = '('
        PARENTHESIS_R = ')'
        BRACKET_L = '['
        BRACKET_R = ']'
        BRACE_L = '{'
        BRACE_R = '}'
        ANGLE_L = '<'
        ANGLE_R = '>'
        ACCENT = '^'
        EQ = '='
        COLON = ':'
        SEMICOLON = ';'
        COMMA = ','
        DOLLAR = '$'
        DOT = '.'
        STAR = '*'
        AT = '@'
        TO = "->"
        HYPHEN = "-"
        IF = "if"
        ELSE = "else"
        FOR = "for"
        IN = "in"
        WHILE = "while"
        MATCH = 'match'
        CATCH = 'catch'
        LET = "let"
        DEF = "def"
        CLASS = 'class'
        TRAIT = 'trait'
        VARIANT = 'variant'
        BITFLAG = 'bitflag'
        EXTENDS = 'extends'
    ]
}

valkyrie ::= (statements [SEMICOLON])*
private statements ::=
    if_statement
  | for_statement
  | while_statement
  | match_statement
  | let_statement
  | def_statement
  | type_statement
  | class_statement
  | trait_statement
  | variant_statement
  | bitflag_statement
  | extends_statement
  | SEMICOLON
  ;
// ---------------------------------------------------------------------------------------------------------------------
if_statement ::= (IF condition block) [else_if_statement* [else_statement]]
else_if_statement ::= ELSE IF condition block;
else_statement ::= ELSE block;

block ::= <<brace_block expression SEMICOLON>>;
condition ::= expression;
// ---------------------------------------------------------------------------------------------------------------------
for_statement ::= FOR pattern IN expression [if_guard] block [else_statement];
if_guard ::= IF condition;

pattern ::= namespace;
// ---------------------------------------------------------------------------------------------------------------------
while_statement ::= WHILE expression block;
// ---------------------------------------------------------------------------------------------------------------------
match_statement ::= MATCH expression block;
// ---------------------------------------------------------------------------------------------------------------------
let_statement ::= LET pattern EQ expression;
// ---------------------------------------------------------------------------------------------------------------------
def_statement ::= DEF expression block;
// ---------------------------------------------------------------------------------------------------------------------
type_statement ::= TYPE SYMBOL EQ block;
// ---------------------------------------------------------------------------------------------------------------------
class_statement ::= CLASS expression block;
// ---------------------------------------------------------------------------------------------------------------------
trait_statement ::= TRAIT SYMBOL block;
// ---------------------------------------------------------------------------------------------------------------------
variant_statement ::= VARIANT expression block;
// ---------------------------------------------------------------------------------------------------------------------
bitflag_statement ::= BITFLAG SYMBOL [COLON type_expression] bitflag_block;
bitflag_block ::= <<brace_block bitflag_item [SEMICOLON]>>;
bitflag_item ::= SYMBOL EQ expression;
// ---------------------------------------------------------------------------------------------------------------------
extends_statement ::= EXTENDS SYMBOL block;
// ---------------------------------------------------------------------------------------------------------------------
private type_expression ::= list | tuple | atoms;
// ---------------------------------------------------------------------------------------------------------------------
private expression ::= list | tuple | atoms;
// ---------------------------------------------------------------------------------------------------------------------
namespace     ::= SYMBOL;
list          ::= <<bracket_block expression COMMA>>
tuple         ::= <<parenthesis expression COMMA>>
private atoms ::= BYTE | INTEGER | DECIMAL | namespace;
// ---------------------------------------------------------------------------------------------------------------------
// parenthesis ( )
meta parenthesis ::= PARENTHESIS_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] PARENTHESIS_R;
// bracket [ ]
meta bracket_block ::= BRACKET_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] BRACKET_R;
// brace { }
private meta brace_block ::= BRACE_L (<<item>>|<<sp>>)* BRACE_R;
// angle < >
meta angle_block ::= ANGLE_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] ANGLE_R;