{
    parserClass = "com.github.valkyrie.language.parser.ValkyrieParser"
    parserUtilClass = "com.github.valkyrie.language.psi.ValkyrieParserExtension"

    extends = "com.github.valkyrie.language.psi.ValkyrieElement"

    psiClassPrefix = "Valkyrie"
    psiImplClassSuffix = "Node"
    psiPackage = "com.github.valkyrie.language.psi"
    psiImplPackage = "com.github.valkyrie.language.psi_node"

    elementTypeHolderClass = "com.github.valkyrie.language.psi.ValkyrieTypes"
    elementTypeClass = "com.github.valkyrie.language.psi.ValkyrieElementType"
    tokenTypeClass = "com.github.valkyrie.language.psi.ValkyrieTokenType"

    psiImplUtilClass = "com.github.valkyrie.language.psi_node.ValkyriePsiExtension"

    tokens = [
        // comment
        COMMENT_DOCUMENT = "Comment Document"
        COMMENT = "Comment"
        COMMENT_BLOCK = "Comment Block"

        // literal
        URL = "Url"
        SYMBOL_XID = "Symbol"
        SYMBOL_RAW = "Symbol"
        BYTE = "Byte"
        STRING_QUOTE = "String Quote"
        STRING_CHAR = "String Character"
        STRING_ESCAPE = "String Escaped"
        STRING_LITERAL = "String Literal"
        COMMENT_LINE = "Comment Line"

        PARENTHESIS_L = '('
        PARENTHESIS_R = ')'
        BRACKET_L = '['
        BRACKET_R = ']'
        BRACE_L = '{'
        BRACE_R = '}'
        ANGLE_L = '<'
        ANGLE_R = '>'
        LESS = "<<"
        GREATER = ">>"
        ACCENT = '^'
        BIND = '='
        EQ = '=='
        NE = '!='
        COLON = ':'
        PROPORTION = "::"
        SEMICOLON = ';'
        DOT = '.'
        COMMA = ','
        STAR = '*'
        AT = '@'
        DOLLAR = '$'
        HASH = '#'
        TO = "->"
        HYPHEN = "-"
        PLUS = "+"
        VERTICAL = "|"
        BANG = "!"
        UNTIL = ".."
        IMPORT = "import"
        EXPORT = "export"
        MODULE = "module"
        IF = "if"
        ELSE = "else"
        FOR = "for"
        FORALL = "forall"
        WHILE = "while"
        MATCH = 'match'
        CATCH = 'catch'
        LET = "let"
        DEF = "def"
        CLASS = 'class'
        TRAIT = 'trait'
        VARIANT = 'variant'
        BITFLAG = 'bitflag'
        EXTENDS = 'extends'
    ]
}

valkyrie ::= (statements [SEMICOLON])*
private statements ::=
    module_statement
  | import_statement
  | export_statement
  | if_statement
  | for_statement
  | while_statement
  | match_statement
  | let_statement
  | def_statement
  | type_statement
  | class_statement
  | trait_statement
  | variant_statement
  | bitflag_statement
  | extends_statement
  | SEMICOLON
  ;
// ---------------------------------------------------------------------------------------------------------------------
module_statement ::= MODULE IDENTIFIER;
// ---------------------------------------------------------------------------------------------------------------------
export_statement ::= EXPORT [<<sequence namespace COMMA>>] export_block;
export_block     ::= <<brace_block import_block COMMA>>;
export_rename    ::= export_name (export_dot export_name)* [AS export_name];
export_name      ::= [AT|HASH] symbol;
export_dot       ::= PROPORTION | DOT;
AS               ::= "as"
// ---------------------------------------------------------------------------------------------------------------------
import_statement ::= IMPORT import_block;
import_block     ::= (export_name export_dot)* export_block | export_rename;
// ---------------------------------------------------------------------------------------------------------------------
if_statement     ::= (IF condition block) [ef_statement* [else_statement]]
ef_statement     ::= ELSE IF condition block;
else_statement   ::= ELSE block;
block            ::= <<brace_block expression SEMICOLON>>;
condition        ::= expression;
// ---------------------------------------------------------------------------------------------------------------------
for_statement ::= FOR pattern IN expression [if_guard] block [else_statement];
if_guard ::= IF condition;
pattern ::=
    [modifiers] case_pattern
  | [modifiers] <<parenthesis modifiers COMMA>>
  | [modifiers] <<bracket_block modifiers COMMA>>
  | <<sequence modifiers COMMA>>;
case_pattern ::=
      CASE function_call;
// ---------------------------------------------------------------------------------------------------------------------
while_statement ::= WHILE expression block;
// ---------------------------------------------------------------------------------------------------------------------
match_statement ::= MATCH expression block;
// ---------------------------------------------------------------------------------------------------------------------
let_statement ::= LET pattern BIND expression;
// ---------------------------------------------------------------------------------------------------------------------
def_statement ::= DEF expression block;
// ---------------------------------------------------------------------------------------------------------------------
type_statement ::= TYPE symbol BIND block;
// ---------------------------------------------------------------------------------------------------------------------
class_statement ::= CLASS symbol [auto_derive] block;
auto_derive ::= COLON <<sequence ([BANG] namespace) PLUS>>;
// ---------------------------------------------------------------------------------------------------------------------
trait_statement ::= TRAIT symbol block;
// ---------------------------------------------------------------------------------------------------------------------
variant_statement ::= VARIANT expression block;
// ---------------------------------------------------------------------------------------------------------------------
bitflag_statement ::= BITFLAG modifiers [bitflag_layout] [auto_derive] bitflag_block;
bitflag_block ::= <<brace_block (bitflag_item|macro_call) SEMICOLON>>;
bitflag_layout ::= PARENTHESIS_L type_expression PARENTHESIS_R;
bitflag_item ::= symbol BIND expression;
// ---------------------------------------------------------------------------------------------------------------------
extends_statement ::= EXTENDS namespace block;
// ---------------------------------------------------------------------------------------------------------------------
private type_expression ::= list | tuple | atoms;
// ---------------------------------------------------------------------------------------------------------------------
private expression ::= term (binary_op term)*;
private term ::= function_call | list | tuple | atoms;
private binary_op ::= VERTICAL | LESS | GREATER | UNTIL;
// ---------------------------------------------------------------------------------------------------------------------
namespace ::= [PROPORTION] symbol (PROPORTION symbol)*;
modifiers ::= namespace*;
symbol    ::= SYMBOL_XID | SYMBOL_RAW;
macro     ::= AT namespace;
// ---------------------------------------------------------------------------------------------------------------------
macro_call    ::= macro [
    <<parenthesis expression COMMA>>
  | <<brace_block pair COMMA>>
  | <<brace_block expression SEMICOLON>>
];
// ---------------------------------------------------------------------------------------------------------------------
function_call ::= namespace [<<parenthesis expression COMMA>>];
// ---------------------------------------------------------------------------------------------------------------------
pair          ::= atoms COLON expression;
list          ::= <<bracket_block expression COMMA>>
tuple         ::= <<parenthesis expression COMMA>>
private atoms ::= BYTE | INTEGER | DECIMAL | namespace;
// ---------------------------------------------------------------------------------------------------------------------
private meta sequence ::= <<item>> (<<sp>> <<item>>)* [<<sp>>];
// parenthesis ( )
private meta parenthesis ::= PARENTHESIS_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] PARENTHESIS_R;
// bracket [ ]
private meta bracket_block ::= BRACKET_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] BRACKET_R;
// brace { }
private meta brace_block ::= BRACE_L (<<item>>|<<sp>>)* BRACE_R;
// angle < >
private meta angle_block ::= ANGLE_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] ANGLE_R;