{
    parserClass = "valkyrie.language.parser.ValkyrieParser"
    parserUtilClass = "valkyrie.language.psi.ValkyrieParserExtension"

    extends = "valkyrie.language.ast.ValkyrieASTBase"

    psiClassPrefix = "Valkyrie"
    psiImplClassSuffix = "Node"
    psiPackage = "valkyrie.language.psi"
    psiImplPackage = "valkyrie.language.psi_node"

    elementTypeHolderClass = "valkyrie.language.psi.ValkyrieTypes"
    elementTypeClass = "valkyrie.language.psi.ValkyrieTokenType"
    tokenTypeClass = "valkyrie.language.psi.ValkyrieTokenType"

    psiImplUtilClass = "valkyrie.language.ast.ASTMethods"
    generateTokenAccessors = false

    tokens = [
        COMMENT = "Comment"
        // literal
        SYMBOL_XID = "Symbol"
        SYMBOL_RAW = "Symbol"
        STRING_START = "StringStart"
        STRING_TEXT = "StringText"
        STRING_END = "StringEnd"
        BYTE = "Byte"

        DOT = '.'
        SEMICOLON = ';'
        COLON = ':'
        OP_PROPORTION = "::"

        OP_AT = "@"
        OP_HASH = "#"

        OP_INC = "++"
        OP_ADD_ASSIGN = "+="
        OP_ADD = "+"
        OP_DEC = "--"
        OP_SUB_ASSIGN = "-="
        OP_SUB = "-"
        OP_MUL_ASSIGN = "*="
        OP_MUL = "*"
        OP_DIV_ASSIGN = "/="
        OP_DIV = "/"
        OP_MOD_ASSIGN = "%="
        OP_MOD = "%"

        OP_AND_ASSIGN = "&="
        OP_AND = "&"
        OP_AND2 = "&&"
        OP_OR_ASSIGN = "|="
        OP_OR = "|"
        OP_OR2 = "||"
        OP_POW = "^"
        // DOTS
        OP_ARROW = "->"
        OP_ARROW2 = "=>"
        //
        OP_EQ = "="
        OP_NE = "!="
        OP_BIND = ":="
        OP_NOT = "!"
        //
        OP_GT = ">"
        OP_GS = "/>"
        OP_GG = ">>"
        OP_GEQ = ">="
        OP_GGG = ">>>"
        //
        OP_LT = "<"
        OP_LS = "</"
        OP_LL = "<<"
        OP_LEQ = "<="
        OP_LLL = "<<<"
        OP_EMPTY = "(!)"

        OP_IS_A = "is"
        OP_NOT_A = "is not"
        OP_NOT_IN = "not_in"
        OP_FORALL = "forall"
        KW_ESCAPING = "KW_WAITING_INPUT"

        PARENTHESIS_L = '('
        PARENTHESIS_R = ')'
        BRACKET_L = '['
        BRACKET_R = ']'
        BRACE_L = '{'
        BRACE_R = '}'
        SLICE_L = '[['
        SLICE_R = ']]'
    ]
}

valkyrie ::= (top_statements | normal_statements  | SEMICOLON)*
private top_statements ::=
    namespace_statement
  | import_statement
  | extension_statement
  | class_statement
  | trait_statement
  | tagged_statement
  | bitflag_statement
  | extends_statement
  | define_statement
  ;
private normal_statements ::=
    control_statement
  | macro_call
  | macro_list
  | for_statement
  | let_statement
  | type_statement
  | loop_statement
  | match_statement
  | catch_statement
  | forall_statement
  | expression
  ;
private expression_statement ::=
    if_statement
  | try_statement
// ---------------------------------------------------------------------------------------------------------------------
namespace_statement ::= KW_NAMESPACE namepath_free {
    mixin="valkyrie.language.mixin.MixinNamespace"
};
// ---------------------------------------------------------------------------------------------------------------------
import_statement ::= KW_IMPORT (import_block|import_item) {
    mixin="valkyrie.language.mixin.MixinImport"
}
import_item      ::= namepath_star [OP_AS identifier|(DOT|OP_PROPORTION) import_block] {
    mixin="valkyrie.language.mixin.MixinImportItem"
}
import_block     ::= <<brace_free import_item (COMMA|SEMICOLON)>>;
namepath_star    ::= identifier ((DOT|OP_PROPORTION) (OP_MUL|identifier))* {
    mixin="valkyrie.language.mixin.MixinNamepath"
}
// ---------------------------------------------------------------------------------------------------------------------
extension_statement ::= KW_EXTENSION identifier COLON namepath_free top_block {
    mixin="valkyrie.language.mixin.MixinExtension"
};
top_block         ::= <<brace_free top_statements SEMICOLON>>
// ---------------------------------------------------------------------------------------------------------------------
if_statement      ::= KW_IF condition normal_block [ef_statement* else_statement] {
    pin=2
    // mixin="valkyrie.language.mixin.MixinIf"
}
ef_statement      ::= kw_else_if condition normal_block;
kw_else_if        ::= KW_ELSE KW_IF;
else_statement    ::= KW_ELSE normal_block;
condition         ::= (case_pattern OP_SET inline_expression | inline_expression);
normal_block      ::= <<brace_free normal_statements SEMICOLON>>;
// ---------------------------------------------------------------------------------------------------------------------
loop_statement    ::= (KW_LOOP | KW_WHILE condition) normal_block [else_statement] {
    pin=1
}
// ---------------------------------------------------------------------------------------------------------------------
for_statement     ::= KW_FOR (case_pattern|normal_pattern) OP_IN inline_expression [if_guard] normal_block [else_statement] {
    pin=1
    mixin="valkyrie.language.mixin.MixinFor"
}
if_guard          ::= KW_IF condition;
case_pattern      ::= KW_CASE [identifier* [namepath]] pattern {
    mixin="valkyrie.language.mixin.MixinCasePattern"
};
normal_pattern    ::=
    [modifiers] '(' pattern_item (COMMA pattern_item)* [COMMA] ')' |
                    pattern_item (COMMA pattern_item)* [COMMA]
{
    mixin="valkyrie.language.mixin.MixinNormalPattern"
};
pattern_item      ::= <<modified identifier>>;
control_statement ::=
    KW_RAISE expression
    | KW_RETURN [expression]
    | KW_RESUME [expression]
    | KW_CONTINUE [jump_label]
    | KW_YIELD ["from"] expression
    | KW_YIELD KW_BREAK [jump_label]
    | KW_BREAK [jump_label]
    ;
jump_label        ::= PARENTHESIS_L identifier PARENTHESIS_R | identifier;
// ---------------------------------------------------------------------------------------------------------------------
private pattern   ::=
    <<parenthesis   id_with_mod COMMA>>
  | <<bracket_block id_with_mod COMMA>>
  | <<brace_block   pattern_pair COMMA>>
  ;
pattern_pair      ::= identifier* COLON pattern_value | identifier* (DOT3|DOT2) identifier | identifier+;
pattern_value     ::= identifier | pattern;
// ---------------------------------------------------------------------------------------------------------------------
match_statement   ::= KW_MATCH match_block {
    pin=1
    // mixin="valkyrie.language.mixin.MixinMatch"
}
match_block       ::= <<brace_free match_expression SEMICOLON>>;
match_expression  ::= case_pattern COLON (normal_statements [SEMICOLON])+
// ---------------------------------------------------------------------------------------------------------------------
// [type_expression|<<bracket_block type_expression separator>>]
try_statement     ::= KW_TRY normal_block {
    pin=1
    // mixin="valkyrie.language.mixin.MixinTry"
}
catch_statement   ::= KW_CATCH match_block {
    pin=1
    // mixin="valkyrie.language.mixin.MixinCatch"
}

with_case         ::= KW_WITH;
else_case         ::= KW_ELSE;
// ---------------------------------------------------------------------------------------------------------------------
new_statement    ::= KW_NEW <<modified type_expression>> [<<brace_block expression COMMA>>] {
    pin=1
}
object_statement ::= KW_OBJECT <<modified type_expression>> [<<brace_block expression COMMA>>] {
    pin=1
}
// ---------------------------------------------------------------------------------------------------------------------
let_statement     ::=
      KW_LET normal_pattern [let_type] [OP_SET normal_statements]
    | KW_LET case_pattern OP_SET normal_statements;
private let_type  ::= COLON <<sequence type_expression COMMA>>;
// ---------------------------------------------------------------------------------------------------------------------
define_statement  ::= KW_DEF <<modified namepath_free>> [generic_define] define_tuple def_type [define_block] {
    pin=2
    mixin="valkyrie.language.mixin.MixinDefine"
    methods=[getNamepath getModifiers]
};
define_tuple      ::= <<parenthesis define_item COMMA>>;
define_item       ::= OP_POW | OP_LT | OP_GT |
    macro_call* [modifiers] [KW_DOTS] identifier [COLON expression] [OP_EQ expression] {
    mixin="valkyrie.language.mixin.MixinDefineItem"
}
define_block      ::= <<brace_block normal_statements SEMICOLON>> {
    pin = 1
}
generic_define    ::= <<bracket_block type_argument COMMA>>
private def_type  ::= [(COLON|OP_ARROW) type_expression]
// ---------------------------------------------------------------------------------------------------------------------
// type Result[T: Debug, E: Error + Debug = Error] = std::result::Result[T];
type_statement    ::= KW_TYPE generic_type [OP_SET type_term] {
    pin=2
    mixin="valkyrie.language.mixin.MixinType"
};
type_expression   ::= type_term (type_binary type_term)*;
type_term         ::= type_atom generic_call?;
type_atom         ::= namepath_free | <<bracket_block namepath_free separator>>;
type_argument     ::= identifier [COLON type_expression];
generic_call      ::= <<bracket_block type_expression COMMA>>
generic_type      ::= identifier [generic_call];
private type_binary ::= OP_AND | OP_OR | OP_ADD | OP_DIV;
// ---------------------------------------------------------------------------------------------------------------------
forall_statement  ::= OP_FORALL <<sequence identifier COMMA>> [forall_block];
forall_block      ::= <<brace_block (expression COLON expression) separator>>;
// ---------------------------------------------------------------------------------------------------------------------
class_statement   ::= KW_CLASS <<modified identifier>> [generic_define] [class_inherit] class_block {
    pin = 2
    mixin = "valkyrie.language.mixin.MixinClass"
    methods = [getIdentifier getModifiers]
};
class_inherit     ::= COLON type_expression;
class_block       ::= <<brace_free (macro_call|class_define|class_item) separator>> {
    pin = 1
    methods=[addChildrenView]
}
class_define      ::= KW_DEF? <<modified identifier>> define_tuple [(COLON|OP_ARROW) type_expression] [define_block] {
    pin = 3
    mixin="valkyrie.language.mixin.MixinClassMethod"
    methods = [getIdentifier getModifiers]
}
class_item        ::= KW_LET? [modifiers] object_key [COLON expression] [OP_SET type_expression] | object_key {
    mixin="valkyrie.language.mixin.MixinClassField"
};
// ---------------------------------------------------------------------------------------------------------------------
object            ::= <<bracket_block object_pair COMMA>>
object_pair       ::= object_key COLON expression;
object_key        ::= SYMBOL_XID | SYMBOL_RAW | INTEGER | KW_IF | KW_CLASS {
    mixin="valkyrie.language.mixin.MixinObjectKey"
}
// ---------------------------------------------------------------------------------------------------------------------
trait_statement   ::= KW_TRAIT <<modified identifier>> [generic_type] [COLON type_expression] class_block {
    pin = 2
    extends="valkyrie.language.mixin.MixinTrait"
    methods=[getIdentifier getModifiers]
};
// ---------------------------------------------------------------------------------------------------------------------
extends_statement ::= KW_EXTENDS [generic_call] <<modified identifier>> [generic_call] [COLON type_expression] class_block {
    pin = 3
    extends="valkyrie.language.mixin.MixinExtends"
    methods=[getIdentifier getModifiers]
}
// ---------------------------------------------------------------------------------------------------------------------
tagged_statement  ::= KW_TAGGED modifiers [[OP_PROPORTION] generic_type] tagged_block {
    mixin="valkyrie.language.mixin.MixinTagged"
};
tagged_block      ::= <<brace_block tagged_item separator>>;
tagged_item       ::= identifier [class_block];
// ---------------------------------------------------------------------------------------------------------------------
bitflag_statement ::= KW_BITFLAG modifiers [bitflag_layout] bitflag_block {
    mixin="valkyrie.language.mixin.MixinBitflag"
};
bitflag_block     ::= <<brace_block (bitflag_item | macro_call) SEMICOLON>>;
bitflag_layout    ::= PARENTHESIS_L expression PARENTHESIS_R;
bitflag_item      ::= identifier OP_SET expression;
// ---------------------------------------------------------------------------------------------------------------------
expression        ::= term (op_binary term)*;
inline_expression ::= inline_term (op_binary inline_term)*;
term              ::= op_prefix* atom term_sfx* {
    mixin="valkyrie.language.mixin.MixinTerm"
};
inline_term       ::= op_prefix* atom line_sfx* {
    mixin="valkyrie.language.mixin.MixinTerm"
};
dot_call          ::= DOT namepath;
// a::b().c::d::[T, U]()?!⟦i:j:k⟧
private line_sfx  ::= op_suffix|call_suffix|generic_type|slice|dot_call
// line_sfx {}.match {...}.catch {...}
private term_sfx  ::= line_sfx|normal_block|[DOT] (catch_statement|match_statement)
private op_binary ::=
      OP_SET | OP_EQ | OP_NE
    | OP_ADD | OP_ADD_ASSIGN
    | OP_SUB | OP_SUB_ASSIGN
    | OP_MUL | OP_MUL_ASSIGN
    | OP_DIV | OP_DIV_ASSIGN | OP_MOD | OP_MOD_ASSIGN
    | OP_POW | OP_POW_ASSIGN
    | OP_GT | OP_LT | DOT_LESS | DOT_EQ | DOT2 | DOT
    | OP_TO
    | OP_AND_THEN | OP_OR_ELSE
    // is | is not
    | OP_NOT_A | OP_IS_A OP_NOT | OP_IS_A | OP_NOT OP_IS_A
    | OP_AS
    // in | not in
    // | OP_IN | OP_NOT_IN | OP_NOT OP_IN
    | OP_UNTIL;
private op_prefix ::= OP_ADD | OP_SUB | OP_NOT | BANG | AMP | DOT3 | DOT2;
private op_suffix ::= BANG | QUESTION;
call_suffix       ::= <<parenthesis expression COMMA>>;
// ---------------------------------------------------------------------------------------------------------------------
macro_call        ::= (OP_AT|OP_HASH) namepath_free [macro_block] {
    mixin="valkyrie.language.mixin.MixinMacroCall"
}
macro_list        ::= KW_MACRO <<bracket_block (namepath_free [macro_block]) COMMA>> {
    mixin="valkyrie.language.mixin.MixinMacroList"
}
macro_block       ::=
    <<parenthesis expression separator>>
  | <<bracket_block expression separator>>
  | <<brace_block expression separator>>;
// ---------------------------------------------------------------------------------------------------------------------
atom           ::= range
    | list | object | tuple | number | string | boolean | namepath | expression_statement
    | new_statement | object_statement;
tuple          ::= <<parenthesis expression COMMA>>
list           ::= <<bracket_block expression COMMA>>
range          ::= <<slice_block slice_item COMMA>>;
slice          ::= <<slice_block slice_item COMMA>>;
slice_item     ::=
    [expression] COLON [expression] COLON [expression]
  | [expression] COLON [expression]
  | [expression] OP_PROPORTION [expression]
  | expression;
// ---------------------------------------------------------------------------------------------------------------------
boolean        ::= "true" | "false";
number         ::= (BYTE | INTEGER | DECIMAL) [identifier] {
    mixin="valkyrie.language.mixin.MixinNumber"
}
string         ::= [identifier] STRING_START STRING_TEXT STRING_END {
    mixin="valkyrie.language.mixin.MixinString"
}
// ---------------------------------------------------------------------------------------------------------------------
namepath_free  ::= identifier ((DOT|OP_PROPORTION) identifier)* {
    mixin="valkyrie.language.mixin.MixinNamepath"
}
namepath       ::= identifier (OP_PROPORTION identifier)* {
    mixin="valkyrie.language.mixin.MixinNamepath"
}
identifier     ::= SYMBOL_XID | SYMBOL_RAW | KW_NAMESPACE | KW_CLASS {
    mixin="valkyrie.language.mixin.MixinIdentifier"
}
modifiers      ::= (identifier !end_m1)+ {
    mixin="valkyrie.language.mixin.MixinModifier"
};
private end_m1 ::= (
    COLON|OP_PROPORTION|SEMICOLON|
    BRACKET_L|BRACKET_R|PARENTHESIS_L|PARENTHESIS_R|BRACE_L|BRACE_R
    COMMA|OP_SET|OP_EQ|DOT|COMMA
);
// ---------------------------------------------------------------------------------------------------------------------
private separator          ::= COMMA | SEMICOLON;
meta modified              ::= [modifiers] <<item>> {
    methods=[addChildrenView]
}
private meta sequence      ::= <<item>> (<<sp>> <<item>>)* [<<sp>>];
// parenthesis ( )
private meta parenthesis   ::= PARENTHESIS_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] PARENTHESIS_R;
// bracket [ ]
private meta bracket_block ::= BRACKET_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] BRACKET_R;
// brace { }
private meta brace_block   ::= BRACE_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] BRACE_R;
// brace { }
private meta brace_free    ::= BRACE_L (<<item>>|<<sp>>)* BRACE_R;
// angle ::< >::
private meta angle_block   ::= OP_LT [<<item>> (<<sp>> <<item>>)* [<<sp>>]] OP_GT;
// angle ⟦ ⟧
private meta slice_block   ::= SLICE_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] SLICE_R;