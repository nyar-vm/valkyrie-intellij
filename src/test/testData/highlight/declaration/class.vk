class A {}

value class B {}



generic {

}
refine class Positive(Integer) {

}

violate {
    y._private_field
}

generic {

}
function a() {
    @assert // 断言
    @assume // 假设
    @refute // 否定
}


generic T, U {
    // forall {f32, f64}
    // // 前置
    // require {
    //
    // }
    // ensure {}// 后置
    // where {}// 约束
}
class A {
    inherit Base,
    inherit Base2,
}


class B {
    item,
}



class A(B, C): C + D {
    pub static a(): Ref⟨B⟩ + D {
        return 1
    }
    _a,
    get a() {
        return _a
    }
    set a() {
        _a = value
    }
}

generic T {
    where {
        T: Trait
    }
}
// test
#[Copy(Clone), Debug]
// test
#derive(PartialEq, Eq, Hash)
class A⟨T⟩ {

}
