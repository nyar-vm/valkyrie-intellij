function name() {}

macro module::`function`(): R / P {

}

inline function package::path::range(min: int, max: int, step: int): Range {
    new lazy std::iterator::Range⟨int⟩() {
        from: min,
        till: max,
        step: step,
        _current: min,
    }
}

micro name(a, k: T, p: U = 1) -> R {
    print("Hello, world!")
}

generic P {
    where { P: AnyType }
}
function Print<P>(w: Write, ..parameters: P) {
    lambda () { };
}




micro name<G, R>(g: G) -> R {
    1 + 1
    a in b
    print("Hello, world!")
}


macro outer<L>(lhs: L) -> String {
    #mut let mut count = 0
}

micro inner<R>(rhs: R) {
    while count < 10 {
        count += 1
        print("{lhs} {rhs}")
    }
}
    "{count}"
}

public static final micro main(mut args: [String]) -> Int {
    outer("Hello")("world")
    return 0
}