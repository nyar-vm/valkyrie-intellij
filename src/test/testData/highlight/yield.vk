namespace legion;

function fibonacci() -> Iterator⟨Integer⟩ {
    let mut a = 0;
    let mut b = 1;
    while true {
        yield b
        b = b + a
        a = b - a
    }
}

self.word ?= b"Hello, World!"



generic T, E { }
extends Result⟨T, E⟩: Perform {
perform(self) -> T / E {
    match self {
        case Success(s): s
        case Failure(e): raise e
    }
}
}

extends<T> Option<T>: Perform {
    perform(self) -> T / null {
        match self {
        Some(s) => s
        None => raise null
    }
}
}

cases A(type) {
case A;
case B;
}



which {
case a @Some(a) if a > 0:
print(1)
case a < 0:
print(-1)
case _: print(0)
}

if case Some(a) = b {
    print(1)
}
else if a < 0 {
    print(-1)
}
else {
    print(0)
}



function main()  {
    for i in fibonacci() {
        if (i > 10) {
            break;
        }
        print(i)
    }
}

~~
#mut #async
function function() {
    return 1;
}
//
function function_cps(async) {
    return async(1);
}

#async {

}