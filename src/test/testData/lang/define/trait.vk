trait A: Trait + Trait
{

}

trait Functor<F> {
   forall A, B {}
   def map(a: F<A>, f: Function<A, B>) -> F<B>;
}

def flatMap<B>(f: A => List[B]): List<B>


trait SemiGroup[T]:
  extension (x: T) def combine (y: T): T

trait Monoid[T] extends SemiGroup[T]:
  def unit: T
given Monoid[String] with
  extension (x: String) def combine (y: String): String = x.concat(y)
  def unit: String = ""


trait SemiGroup {
    def combine(self, rhs: Self): Self
}

trait Monoid: SemiGroup + Default {
    def empty(): Self
}

extends String: Monoid<String> {
    def combine(self, y: Self) = self.concat(y)
    def unit() = ""
}

let a = String::unit()

extends T: T::


trait Functor[F[_]]:
  def map[A, B](x: F[A], f: A => B): F[B]
given Functor[List] with
  def map[A, B](x: List[A], f: A => B): List[B] =
    x.map(f) // List already has a `map` method


trait Functor<F<_>> {
    def flat_map<A, B>(self: F<A>, f: A -> B): F<B>
}


trait Functor {
    fn flat_map<A, B>(self: Functor<A>, f: A -> B) -> Functor<B>;
}

trait Functor {
    type Unwrapped;
    type Wrapped<B>: Functor;

    fn flat_map<F, B>(self, f: F) -> Self::Wrapped<B>
    where
        F: FnMut(Self::Unwrapped) -> B;
}

trait Functor {
    def flat_map<A, B, F: Mutable<A> -> B>(self: Self<A>, f: F) -> Self<B>;
}

extends Option: Functor {
    fn map<A, B, F: FnMut(A) -> B>(self: Option<A>, f: F) -> Option<B> {
        match self {
            Some(a) => Some(f(a)),
            None => None,
        }
    }
}

trait HKT<A, B> {
    type URI;
    type Target;
}

trait Functor<A, B>: HKT<A, B> {
    fn fmap<F>(self, f: F) -> <Self as HKT<A, B>>::Target
        where F: A -> B;
}

forall {Self : * -> *}
trait Functor {
    forall F { F: A -> B }
    def fmap<F>(self, f : F) -> Self<B>
}

trait<B> Functor {
    fn fmap<F>(self, f: F) -> Self::Target
    where
        F: FnOnce(Self::Current) -> B;
}

trait<A> Functor {
    fn fmap<B>(self, f: A -> B) -> Self<B>
}

forall A {Self : A -> _}
trait Functor {
    def flat_map<B>(f : A -> B) -> Self<B>
}
trait<A> Pointed { func point(x : A) -> Self<A> }


// ignore Functor, etc. dependencies for this demo
trait<A> Monad {
  def unit() -> Self<A>
  def bind<B>(self, f : A -> Self<B>) -> Self<B>
}

trait<M: Monad, A> MonadTrans {
  init(lifting: M<A>) -> Self<M, A>
}

extends<A> Array<A>: Functor {
    def fmap<B>(self, f: A -> B) -> Array<B> {
        return map(f, self)
    }
}



extends<A> Array<A>: Functor<A> {
    type A = i32;
    def fmap<B>(self, f: A -> B) -> Array<B> {
        return map(f, self)
    }
}